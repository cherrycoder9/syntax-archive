# 연산자 심화

## 연산자 우선순위를 고려한 코드 최적화

### 연산자 우선순위의 기본 개념

JavaScript에서 연산자 우선순위는 표현식 내 연산자들의 실행 순서를 결정함. 우선순위가 높은 연산자가 먼저 실행되며, 같은 우선순위일 경우 왼쪽에서 오른쪽으로 실행됨.

```javascript
// 예시: 곱셈이 덧셈보다 우선순위가 높음
console.log(2 + 3 * 4); // 14 (3 * 4가 먼저 계산됨)
```

### 성능 최적화를 위한 우선순위 활용

- 불필요한 괄호 제거

괄호는 가독성을 높이지만, 과도한 사용은 JavaScript 엔진의 파싱 시간을 늘릴 수 있음.

```javascript
// 비효율적
let result = ((a + b) * c) / (d - e);

// 최적화 (우선순위를 고려하여 불필요한 괄호 제거)
let result = (a + b) * c / (d - e);
```

- 단락 평가(Short-circuit evaluation) 활용

논리 연산자의 우선순위를 이용해 조건부 실행을 최적화할 수 있음.

```javascript
// 덜 효율적
if (condition) {
doSomething();
}

// 더 효율적 (&&의 우선순위 활용)
condition && doSomething();

// 3항 연산자 대신 || 사용
let value = someValue || defaultValue;
```

- 비트 연산자 우선순위 활용

비트 연산은 다른 산술 연산보다 우선순위가 낮음. 이를 활용해 마스킹 연산을 최적화할 수 있음.

```javascript
// 비효율적
let masked = (value & MASK) + offset;

// 최적화 (불필요한 괄호 제거)
let masked = value & MASK + offset;
```

### 복잡한 표현식 최적화

- 연산 분리

복잡한 표현식은 여러 단계로 나누어 최적화할 수 있음.

```javascript
// 복잡한 표현식
let result = a + b * c - d / e + f * (g + h);

// 최적화: 중간 결과를 변수에 저장
let temp1 = b * c;
let temp2 = d / e;
let temp3 = g + h;
let result = a + temp1 - temp2 + f * temp3;
```

- 루프 최적화

연산자 우선순위를 고려해 루프 내 연산을 최적화할 수 있음.

```javascript
// 비효율적
for (let i = 0; i < arr.length; i++) {
  result += arr[i] * factor + offset;
}

// 최적화: 불변 연산을 루프 밖으로
let adjustedFactor = factor * offset;
for (let i = 0; i < arr.length; i++) {
  result += arr[i] + adjustedFactor;
}
```

### 연산자 우선순위 표 (일부)

높은 순에서 낮은 순으로:

1. `()` 그룹화
2. `.` 멤버 접근, `[]` 계산된 멤버 접근, `new` (인자 있는)
3. `new` (인자 없는)
4. `()` 함수 호출
5. `++`, `--` (후위)
6. `!`, `~`, `+`, `-`, `++`, `--` (전위), `typeof`, `void`, `delete`
7. `**` (거듭제곱)
8. `*`, `/`, `%`
9. `+`, `-`
10. `<<`, `>>`, `>>>`
11. `<`, `<=`, `>`, `>=`, `in`, `instanceof`
12. `==`, `!=`, `===`, `!==`
13. `&`
14. `^`
15. `|`
16. `&&`
17. `||`
18. `??` (널 병합)
19. `?:` (조건 연산자)
20. `=`, `+=`, `-=`, `*=` 등 (할당)
21. `,` (쉼표)

### 주의사항 및 팁

1. 가독성 vs 성능
   우선순위를 고려한 최적화가 항상 최선은 아님. 때로는 명시적인 괄호 사용이 코드의 의도를 더 잘 전달할 수 있음.

2. JIT 최적화 고려
   현대 JavaScript 엔진은 JIT 컴파일을 통해 많은 최적화를 수행함. 미세한 수준의 최적화보다는 전체적인 알고리즘 개선에 집중하는 게 더 효과적일 수 있음.

3. 측정의 중요성
   최적화 전후로 항상 성능을 측정해볼 것. 예상과 다른 결과가 나올 수 있음.

    ```javascript
    // 성능 측정 예시
    console.time('최적화 전');
    // 최적화 전 코드
    console.timeEnd('최적화 전');

    console.time('최적화 후');
    // 최적화 후 코드
    console.timeEnd('최적화 후');
    ```

연산자 우선순위를 고려한 최적화는 미세한 수준의 최적화지만, 대규모 애플리케이션에서는 누적 효과로 인해 상당한 성능 향상을 가져올 수 있음. 다만 항상 가독성과 유지보수성을 함께 고려해야 함. 극단적인 최적화보다는 전체적인 코드 품질과 균형을 잡는 게 중요함.
