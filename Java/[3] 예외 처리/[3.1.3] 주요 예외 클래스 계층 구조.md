# 예외 처리

## 주요 예외 클래스 계층 구조

### Throwable 클래스

Throwable은 자바의 예외 처리 시스템의 근간을 이루는 최상위 클래스임. 모든 예외와 에러는 이 클래스를 상속받아 구현됨. Throwable 클래스는 다음과 같은 주요 메서드를 제공함:

- `getMessage()`: 예외 메시지를 반환
- `printStackTrace()`: 예외가 발생한 메서드의 호출 스택을 출력
- `getStackTrace()`: 예외 발생 당시의 스택 정보를 StackTraceElement 배열로 반환

### Exception 계열

Exception 클래스는 Throwable을 상속받으며, 프로그램에서 처리 가능한 예외를 나타냄. 주요 하위 클래스들은 다음과 같음:

1. IOException
   - 파일 입출력, 네트워크 통신 등에서 발생
   - 예시: FileNotFoundException, SocketException

   ```java
   try (FileInputStream fis = new FileInputStream("nonexistent.txt")) {
       // 파일 읽기 작업
   } catch (FileNotFoundException e) {
       System.out.println("파일을 찾을 수 없음: " + e.getMessage());
   } catch (IOException e) {
       System.out.println("입출력 오류: " + e.getMessage());
   }
   ```

2. SQLException
   - 데이터베이스 관련 작업에서 발생
   - 예시: SQLSyntaxErrorException

   ```java
   try (Connection conn = DriverManager.getConnection(url, user, password)) {
       Statement stmt = conn.createStatement();
       ResultSet rs = stmt.executeQuery("SELECT * FROM non_existent_table");
   } catch (SQLException e) {
       System.out.println("SQL 오류: " + e.getMessage());
   }
   ```

3. RuntimeException
   - 프로그램의 논리적 오류나 예상치 못한 상황에서 발생
   - 주요 하위 클래스:
     - NullPointerException
     - ArrayIndexOutOfBoundsException
     - IllegalArgumentException

   ```java
   public void divideNumbers(int a, int b) {
       try {
           int result = a / b;
           System.out.println("결과: " + result);
       } catch (ArithmeticException e) {
           System.out.println("0으로 나눌 수 없음: " + e.getMessage());
       }
   }
   ```

### Error 계열

Error 클래스도 Throwable을 상속받지만, 주로 JVM이나 하드웨어 관련 문제를 나타냄. 대부분의 경우 프로그램에서 직접 처리하기 어려운 상황을 의미함.

1. VirtualMachineError
   - OutOfMemoryError: 메모리 부족 시 발생
   - StackOverflowError: 스택 메모리 초과 시 발생

   ```java
   public void recursiveMethod() {
       try {
           recursiveMethod();  // 무한 재귀 호출
       } catch (StackOverflowError e) {
           System.out.println("스택 오버플로우 발생: " + e.getMessage());
       }
   }
   ```

2. LinkageError
   - NoClassDefFoundError: 클래스 정의를 찾을 수 없을 때 발생
   - UnsatisfiedLinkError: 네이티브 메서드 링크 실패 시 발생

### 예외 처리 전략

1. 구체적인 예외부터 처리하기
   - 여러 예외를 처리할 때는 구체적인 예외부터 잡아 처리해야 함

   ```java
   try {
       // 예외 발생 가능한 코드
   } catch (FileNotFoundException e) {
       System.out.println("파일을 찾을 수 없음");
   } catch (IOException e) {
       System.out.println("입출력 오류 발생");
   } catch (Exception e) {
       System.out.println("기타 예외 발생");
   }
   ```

2. 멀티 catch 블록 사용하기
   - Java 7부터 도입된 기능으로, 여러 예외를 한 번에 처리할 수 있음

   ```java
   try {
       // 예외 발생 가능한 코드
   } catch (IOException | SQLException e) {
       System.out.println("입출력 또는 SQL 오류: " + e.getMessage());
   }
   ```

3. 예외 전환하기
   - 저수준의 예외를 잡아서 더 추상화된 고수준의 예외로 변환하여 던질 수 있음

   ```java
   public void processFile(String fileName) throws BusinessException {
       try {
           // 파일 처리 로직
       } catch (IOException e) {
           throw new BusinessException("파일 처리 중 오류 발생", e);
       }
   }
   ```

예외 계층 구조를 이해하고 적절히 활용하면, 더 견고하고 유지보수가 쉬운 코드를 작성할 수 있음. 각 예외의 특성을 고려하여 상황에 맞는 처리 전략을 선택해야 함.
