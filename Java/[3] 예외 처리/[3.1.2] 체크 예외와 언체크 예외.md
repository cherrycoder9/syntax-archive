# 예외 처리

## 체크 예외와 언체크 예외

### 체크 예외의 특성

체크 예외는 컴파일러가 강제로 처리를 요구하는 예외 유형임. 이 예외들은 프로그램 실행 전에 미리 대비해야 하는 상황을 나타냄. 주로 외부 환경과의 상호작용에서 발생할 수 있는 문제를 다룸.

체크 예외의 주요 특징:

- 컴파일 시점에 확인됨
- `try-catch` 블록으로 처리하거나 `throws` 키워드로 예외를 떠넘겨야 함
- `Exception` 클래스를 상속받되 `RuntimeException`을 상속하지 않은 예외들이 해당됨

체크 예외 처리 예시:

```java
import java.io.FileReader;
import java.io.IOException;

public class CheckedExceptionDemo {
    public static void readFile(String fileName) throws IOException {
        FileReader reader = new FileReader(fileName);
        // 파일 읽기 로직
        reader.close();
    }

    public static void main(String[] args) {
        try {
            readFile("data.txt");
        } catch (IOException e) {
            System.out.println("파일 읽기 실패: " + e.getMessage());
        }
    }
}
```

### 언체크 예외의 특징

언체크 예외는 프로그램의 논리적 오류나 예상치 못한 상황에서 발생하는 예외임. 컴파일러가 처리를 강제하지 않아 개발자의 판단에 따라 처리할 수 있음.

언체크 예외의 주요 특징:

- 런타임에 발생함
- 명시적인 예외 처리가 강제되지 않음
- `RuntimeException` 클래스를 상속받은 예외들이 해당됨

언체크 예외 발생 예시:

```java
public class UncheckedExceptionDemo {
    public static void divideNumbers(int a, int b) {
        System.out.println(a / b);  // b가 0이면 ArithmeticException 발생
    }

    public static void main(String[] args) {
        divideNumbers(10, 0);
    }
}
```

### 체크 예외와 언체크 예외의 차이점

1. 처리 의무성:
   - 체크 예외: 반드시 처리해야 함
   - 언체크 예외: 처리가 선택적임

2. 발생 시점:
   - 체크 예외: 컴파일 시 확인 가능
   - 언체크 예외: 주로 런타임에 발견됨

3. 예외 계층:
   - 체크 예외: `Exception` 직계 자손
   - 언체크 예외: `RuntimeException` 하위 클래스

4. 주요 사용 사례:
   - 체크 예외: 외부 리소스 접근, 네트워크 통신 등
   - 언체크 예외: 프로그래밍 오류, 예상치 못한 입력값 처리 등

### 예외 처리 전략

- 체크 예외: 발생 가능성이 높고 복구 가능한 상황에 사용함. 예외 처리를 통해 프로그램의 안정성을 높일 수 있음
- 언체크 예외: 프로그램 로직 오류를 나타내는 경우가 많음. 코드 개선을 통해 예외 발생을 방지하는 것이 중요함

예외 처리 시 주의할 점:

- 과도한 체크 예외 사용은 코드의 가독성을 떨어뜨릴 수 있음
- 언체크 예외라도 중요한 비즈니스 로직에서는 적절히 처리해야 함
- 예외 처리 시 구체적인 예외 타입을 사용하여 더 정확한 오류 처리를 할 것
