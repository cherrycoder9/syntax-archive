# 예외 처리

## 다중 catch 블록과 예외 처리 순서

### 다중 catch 블록의 필요성

다중 catch 블록을 사용하면 하나의 try 블록에서 발생할 수 있는 여러 유형의 예외를 각각 다르게 처리할 수 있음. 이는 예외 상황에 따라 더 세밀하고 적절한 대응을 가능하게 함.

### 기본 구조와 예시

다중 catch 블록의 기본 구조:

```java
try {
    // 예외 발생 가능 코드
} catch (SpecificException1 e) {
    // 첫 번째 예외 처리
} catch (SpecificException2 e) {
    // 두 번째 예외 처리
} catch (Exception e) {
    // 기타 예외 처리
}
```

실제 예시:

```java
public class MultiCatchExample {
    public static void main(String[] args) {
        try {
            int[] numbers = {1, 2, 3};
            System.out.println(numbers[5]);  // ArrayIndexOutOfBoundsException
            int result = 10 / 0;  // ArithmeticException
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("배열 인덱스 초과: " + e.getMessage());
        } catch (ArithmeticException e) {
            System.out.println("산술 연산 오류: " + e.getMessage());
        } catch (Exception e) {
            System.out.println("기타 예외 발생: " + e.getMessage());
        }
    }
}
```

이 예시에서는 배열 인덱스 초과와 0으로 나누기 오류를 각각 다르게 처리함.

### 예외 처리 순서의 중요성

예외 처리 순서는 매우 중요함. 구체적인 예외를 먼저 처리하고, 일반적인 예외를 나중에 처리해야 함. 이는 예외 클래스의 상속 구조와 관련이 있음.

잘못된 순서의 예:

```java
try {
    // 예외 발생 가능 코드
} catch (Exception e) {
    System.out.println("일반 예외 발생");
} catch (ArithmeticException e) {  // 컴파일 오류 발생
    System.out.println("산술 연산 예외 발생");
}
```

이 코드는 컴파일되지 않음. `ArithmeticException`은 `Exception`의 하위 클래스이므로, `Exception`을 먼저 캐치하면 `ArithmeticException`은 절대 실행되지 않기 때문.

올바른 순서의 예:

```java
try {
    // 예외 발생 가능 코드
} catch (ArithmeticException e) {
    System.out.println("산술 연산 예외 발생");
} catch (Exception e) {
    System.out.println("일반 예외 발생");
}
```

### 다중 예외 처리 (Java 7+)

Java 7부터는 하나의 catch 블록에서 여러 예외를 동시에 처리할 수 있음:

```java
try {
    // 예외 발생 가능 코드
} catch (IOException | SQLException e) {
    System.out.println("입출력 또는 SQL 예외 발생: " + e.getMessage());
    // 공통 처리 로직
}
```

이 방식은 코드 중복을 줄이고 가독성을 높일 수 있음. 단, 이렇게 그룹화된 예외들은 상속 관계에 있으면 안 됨.

### 예외 처리의 세부 전략

1. 로깅을 활용한 예외 처리:

    ```java
    import java.util.logging.Logger;

    public class ExceptionLoggingExample {
        private static final Logger logger = Logger.getLogger(ExceptionLoggingExample.class.getName());

        public static void main(String[] args) {
            try {
                // 예외 발생 가능 코드
            } catch (IOException e) {
                logger.warning("입출력 예외 발생: " + e.getMessage());
            } catch (SQLException e) {
                logger.severe("SQL 예외 발생: " + e.getMessage());
            }
        }
    }
    ```

2. 예외 전환을 통한 추상화:

    ```java
    public void processFile(String fileName) throws BusinessException {
        try {
            // 파일 처리 로직
        } catch (IOException e) {
            throw new BusinessException("파일 처리 중 오류 발생", e);
        }
    }
    ```

이 방식은 저수준의 예외를 비즈니스 로직에 맞는 고수준의 예외로 변환하여 예외 처리를 추상화함.

다중 catch 블록과 적절한 예외 처리 순서를 활용하면, 더 견고하고 유지보수가 쉬운 예외 처리 로직을 구현할 수 있음. 예외 처리는 단순히 오류를 잡는 것이 아니라, 프로그램의 안정성과 가독성을 높이는 중요한 기법임을 항상 기억해야 함.
