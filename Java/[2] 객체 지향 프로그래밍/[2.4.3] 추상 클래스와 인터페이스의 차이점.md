# 다형성

## 추상 클래스와 인터페이스의 차이점

### 추상 클래스와 인터페이스의 개념

#### 추상 클래스

추상 클래스는 하나 이상의 추상 메서드를 포함할 수 있는 클래스임. 객체를 직접 생성할 수 없으며, 상속받는 자식 클래스에서 추상 메서드를 구현해야 함.

#### 인터페이스

인터페이스는 클래스가 구현해야 하는 메서드의 집합을 정의함. 메서드의 선언만 포함하며, 실제 구현은 포함하지 않음. 클래스는 여러 인터페이스를 구현할 수 있음.

<!-- markdownlint-disable MD024 -->
### 추상 클래스와 인터페이스의 차이점
<!-- markdownlint-enable MD024 -->

#### 공통점

- 다형성 구현에 사용됨
- 메서드 선언 가능
- 직접 인스턴스화 불가

#### 차이점

1. **구현 여부**
   - 추상 클래스: 메서드 구현 포함 가능
   - 인터페이스: 메서드 구현 불가 (자바 8 이후 default 메서드 예외)

2. **상속/구현 방식**
   - 추상 클래스: 단일 상속만 가능
   - 인터페이스: 다중 구현 가능

3. **멤버 변수**
   - 추상 클래스: 멤버 변수 가능
   - 인터페이스: 상수만 가능

4. **접근 제어자**
   - 추상 클래스: 다양한 접근 제어자 사용 가능
   - 인터페이스: 메서드 선언에 `public` 기본 사용

### 코드 예제

#### 추상 클래스 예제

```java
abstract class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }

    abstract void makeSound();

    void eat() {
        System.out.println(name + "이(가) 먹고 있음.");
    }
}

class Dog extends Animal {
    Dog(String name) {
        super(name);
    }

    @Override
    void makeSound() {
        System.out.println(name + "이(가) 멍멍 짖음");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Dog("멍멍이");
        dog.makeSound();
        dog.eat();
    }
}
```

#### 인터페이스 예제

```java
interface Animal {
    void makeSound();
    void eat();
}

class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍");
    }

    @Override
    public void eat() {
        System.out.println("개가 먹이를 먹음");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.makeSound();
        myDog.eat();
    }
}
```

### 추상 클래스와 인터페이스의 실제 사용 사례

#### 추상 클래스 사용 사례

```java
abstract class Shape {
    abstract double getArea();

    void display() {
        System.out.println("도형을 표시함");
    }
}

class Circle extends Shape {
    double radius;

    Circle(double radius) {
        this.radius = radius;
    }

    @Override
    double getArea() {
        return Math.PI * radius * radius;
    }
}

public class ShapeDemo {
    public static void main(String[] args) {
        Shape circle = new Circle(5.0);
        System.out.println("면적: " + circle.getArea());
        circle.display();
    }
}
```

이 예제에서 `Shape` 추상 클래스는 공통 메서드 `display`와 추상 메서드 `getArea`를 제공함. `Circle` 클래스는 `Shape`를 상속받아 `getArea`를 구현함.

#### 인터페이스 사용 사례

```java
interface Payment {
    void pay();
}

class CreditCardPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("신용카드로 결제함");
    }
}

class PayPalPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("페이팔로 결제함");
    }
}

public class PaymentDemo {
    public static void main(String[] args) {
        Payment creditCardPayment = new CreditCardPayment();
        Payment payPalPayment = new PayPalPayment();
        creditCardPayment.pay();
        payPalPayment.pay();
    }
}
```

이 예제에서 `Payment` 인터페이스는 결제 방식을 정의함. `CreditCardPayment`와 `PayPalPayment` 클래스는 이 인터페이스를 구현하여 각각의 결제 방식을 제공함.

추상 클래스는 공통 기능을 제공하면서 일부 기능은 자식 클래스에서 구현하도록 할 때 유용함. 인터페이스는 여러 클래스가 동일한 메서드를 구현하도록 강제하여 일관된 동작을 보장할 때 사용됨.
