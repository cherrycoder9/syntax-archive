# 다형성

## 인터페이스 정의와 구현

### 인터페이스의 개념

인터페이스는 클래스가 구현해야 할 메서드의 집합을 정의함. 메서드의 선언만 포함하며, 실제 구현은 포함하지 않음. 클래스 설계 시 인터페이스를 사용하면 특정 메서드 구현을 강제할 수 있음.

#### 인터페이스의 목적

1. **계약 제공**: 클래스에 특정 기능 구현을 요구하는 계약 역할
2. **다중 상속 효과**: 자바의 클래스 다중 상속 제한을 우회하는 방법
3. **유연성 및 확장성**: 다양한 클래스가 동일 인터페이스 구현 가능

### 인터페이스 정의 예제

```java
interface Animal {
    void makeSound();
    void eat();
}

class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍");
    }

    @Override
    public void eat() {
        System.out.println("개가 먹이를 먹음");
    }
}

class Cat implements Animal {
    @Override
    public void makeSound() {
        System.out.println("야옹");
    }

    @Override
    public void eat() {
        System.out.println("고양이가 먹이를 먹음");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        myDog.makeSound();
        myDog.eat();
        myCat.makeSound();
        myCat.eat();
    }
}
```

이 예제에서 `Animal` 인터페이스는 `makeSound`와 `eat` 메서드를 선언함. `Dog`와 `Cat` 클래스는 이 인터페이스를 구현하여 각 메서드를 정의함.

### 인터페이스의 실제 사용 사례

#### 사례 1: 데이터 처리

```java
interface DataProcessor {
    void process();
}

class TextDataProcessor implements DataProcessor {
    @Override
    public void process() {
        System.out.println("텍스트 데이터 처리 중");
    }
}

class ImageDataProcessor implements DataProcessor {
    @Override
    public void process() {
        System.out.println("이미지 데이터 처리 중");
    }
}

public class DataProcessingDemo {
    public static void main(String[] args) {
        DataProcessor textProcessor = new TextDataProcessor();
        DataProcessor imageProcessor = new ImageDataProcessor();

        textProcessor.process();
        imageProcessor.process();
    }
}
```

이 예제에서 `DataProcessor` 인터페이스는 `process` 메서드를 선언함. `TextDataProcessor`와 `ImageDataProcessor` 클래스는 각각의 데이터 처리 방식을 구현함.

#### 사례 2: 결제 시스템

```java
interface Payment {
    void pay();
}

class CreditCardPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("신용카드로 결제");
    }
}

class PayPalPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("페이팔로 결제");
    }
}

public class PaymentDemo {
    public static void main(String[] args) {
        Payment creditCardPayment = new CreditCardPayment();
        Payment payPalPayment = new PayPalPayment();

        creditCardPayment.pay();
        payPalPayment.pay();
    }
}
```

이 예제에서 `Payment` 인터페이스는 `pay` 메서드를 선언함. `CreditCardPayment`와 `PayPalPayment` 클래스는 각각의 결제 방식을 구현함.

#### 사례 3: 네트워크 통신

```java
interface Network {
    void connect();
    void disconnect();
}

class WiFiNetwork implements Network {
    @Override
    public void connect() {
        System.out.println("WiFi 연결 중");
    }

    @Override
    public void disconnect() {
        System.out.println("WiFi 연결 해제 중");
    }
}

class EthernetNetwork implements Network {
    @Override
    public void connect() {
        System.out.println("유선 연결 중");
    }

    @Override
    public void disconnect() {
        System.out.println("유선 연결 해제 중");
    }
}

public class NetworkDemo {
    public static void main(String[] args) {
        Network wifi = new WiFiNetwork();
        Network ethernet = new EthernetNetwork();

        wifi.connect();
        wifi.disconnect();
        ethernet.connect();
        ethernet.disconnect();
    }
}
```

이 예제에서 `Network` 인터페이스는 `connect`와 `disconnect` 메서드를 선언함. `WiFiNetwork`와 `EthernetNetwork` 클래스는 각각의 네트워크 연결 방식을 구현함.

인터페이스를 사용하면 다양한 구현을 통일된 방식으로 다룰 수 있어, 코드의 유연성과 확장성이 높아짐.
