# 객체 지향 프로그래밍

## 상속

### 상속의 개념과 구현

#### 상속의 개념

상속은 기존 클래스를 재사용해 새로운 클래스를 만드는 방식임. 코드 재사용성을 높이고, 계층 구조로 클래스 관계를 정의함. '부모 클래스'의 특성을 '자식 클래스'가 물려받아 사용, 확장, 재정의할 수 있음.

#### 상속의 장점

1. **코드 재사용**: 기존 클래스 활용해 새 클래스 쉽게 생성.
2. **유지보수 용이**: 공통 코드는 부모 클래스에 작성, 변경 시 한 곳만 수정.
3. **다형성 구현**: 상속을 통해 다형성 구현 가능.

#### 상속 구현 방법

자바에서는 `extends` 키워드로 상속 구현. 예시:

```java
// 부모 클래스
class Animal {
    String name;

    void eat() {
        System.out.println(name + "이(가) 먹이를 먹습니다.");
    }
}

// 자식 클래스
class Dog extends Animal {
    String breed;

    void bark() {
        System.out.println(name + "이(가) 짖습니다: 왈왈!");
    }
}

// 사용 예
public class Main {
    public static void main(String[] args) {
        var myDog = new Dog();
        myDog.name = "멍멍이"; // 부모 클래스 필드 사용
        myDog.breed = "골든 리트리버"; // 자식 클래스 필드 사용
        myDog.eat(); // 부모 클래스 메서드 사용
        myDog.bark(); // 자식 클래스 메서드 사용
    }
}
```

이 예제에서 `Dog`는 `Animal`을 상속받아 부모의 특성을 사용하면서 자신만의 특성도 추가함.

#### 메서드 오버라이딩

자식 클래스에서 부모 클래스의 메서드를 재정의하는 것을 메서드 오버라이딩이라 함.

```java
class Animal {
    void makeSound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("개가 짖습니다: 왈왈!");
    }
}

// 사용 예
var myDog = new Dog();
myDog.makeSound(); // "개가 짖습니다: 왈왈!" 출력
```

`@Override` 어노테이션은 오버라이딩 의도를 명확히 하고, 실수 방지에 도움을 줌.

#### super 키워드

`super` 키워드는 자식 클래스에서 부모 클래스 멤버에 접근하거나 생성자를 호출할 때 사용함.

```java
class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }

    void introduce() {
        System.out.println("저는 " + name + "입니다.");
    }
}

class Dog extends Animal {
    String breed;

    Dog(String name, String breed) {
        super(name); // 부모 클래스 생성자 호출
        this.breed = breed;
    }

    @Override
    void introduce() {
        super.introduce(); // 부모 클래스 메서드 호출
        System.out.println("저는 " + breed + " 품종입니다.");
    }
}

// 사용 예
var myDog = new Dog("멍멍이", "골든 리트리버");
myDog.introduce();
```

#### 상속의 실제 사용 사례

상속은 코드 재사용성을 높이고 클래스 계층 구조를 체계적으로 관리하는 데 유용함. 예를 들어, 간단한 직원 관리 시스템을 구현해보자:

```java
// 기본 직원 클래스
class Employee {
    protected String name;
    protected int id;
    protected double salary;

    public Employee(String name, int id, double salary) {
        this.name = name;
        this.id = id;
        this.salary = salary;
    }

    public void work() {
        System.out.println(name + "이(가) 일하고 있습니다.");
    }

    public double calculateSalary() {
        return salary;
    }
}

// 관리자 클래스
class Manager extends Employee {
    private double bonus;

    public Manager(String name, int id, double salary, double bonus) {
        super(name, id, salary);
        this.bonus = bonus;
    }

    @Override
    public void work() {
        System.out.println(name + " 관리자가 직원들을 관리하고 있습니다.");
    }

    @Override
    public double calculateSalary() {
        return super.calculateSalary() + bonus;
    }
}

// 개발자 클래스
class Developer extends Employee {
    private int overtimeHours;

    public Developer(String name, int id, double salary, int overtimeHours) {
        super(name, id, salary);
        this.overtimeHours = overtimeHours;
    }

    @Override
    public void work() {
        System.out.println(name + " 개발자가 코딩을 하고 있습니다.");
    }

    @Override
    public double calculateSalary() {
        return super.calculateSalary() + (overtimeHours * 100); // 초과 근무 수당
    }
}
```

이 예제에서 `Manager`와 `Developer` 클래스는 `Employee` 클래스를 상속받아 각자의 특성에 맞게 메서드를 오버라이딩함.

사용 예시:

```java
public class Main {
    public static void main(String[] args) {
        var emp = new Employee("김일반", 1001, 3000000);
        var mgr = new Manager("박관리", 2001, 5000000, 1000000);
        var dev = new Developer("이개발", 3001, 4000000, 10);

        emp.work();
        mgr.work();
        dev.work();

        System.out.println(emp.name + "의 급여: " + emp.calculateSalary());
        System.out.println(mgr.name + "의 급여: " + mgr.calculateSalary());
        System.out.println(dev.name + "의 급여: " + dev.calculateSalary());
    }
}
```

이 시스템에서 상속의 이점:

1. **코드 재사용**: `Employee` 클래스의 기본 기능을 `Manager`와 `Developer`가 재사용함.
2. **확장성**: 새로운 직원 유형(예: 'Designer')을 쉽게 추가할 수 있음.
3. **다형성**: 모든 직원 객체를 `Employee` 타입으로 다룰 수 있어 유연한 코드 작성 가능.

#### 상속 사용 시 주의사항

1. **단일 상속**: 자바는 클래스의 다중 상속을 지원하지 않음. 한 클래스는 하나의 클래스만 상속 가능.
2. **상속의 남용 주의**: 불필요한 상속은 코드를 복잡하게 만들 수 있음. "is-a" 관계가 성립할 때만 사용.
3. **캡슐화 유지**: 상속으로 인해 부모 클래스의 구현 세부사항이 자식 클래스에 노출되지 않도록 주의.

상속은 강력한 도구지만, 적절히 사용해야 함. 컴포지션(Composition)이나 인터페이스 구현 등 다른 방법도 고려해 볼 것.
