# 다형성

## 다형성의 실제 응용

### 다형성의 개념

다형성은 객체 지향 프로그래밍의 핵심 특징 중 하나로, 같은 타입의 객체가 다양한 형태로 동작할 수 있게 함. 주로 메서드 오버라이딩과 인터페이스를 통해 구현됨.

#### 다형성의 장점

1. **코드 재사용성**: 공통 인터페이스로 다양한 객체 처리 가능
2. **유연성**: 프로그램의 유연성과 확장성 향상
3. **유지보수성**: 코드 변경 시 영향 최소화로 유지보수 용이

### 다형성의 실제 사용 사례

#### 사례 1: 동물 울음소리 프로그램

```java
class Animal {
    void makeSound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("멍멍");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("야옹");
    }
}

public class Zoo {
    public static void main(String[] args) {
        var animals = new Animal[]{new Dog(), new Cat(), new Animal()};

        for (var animal : animals) {
            animal.makeSound(); // 각 동물의 울음소리 출력
        }
    }
}
```

이 예제에서 `Animal` 클래스를 상속받은 `Dog`와 `Cat` 클래스가 `makeSound` 메서드를 오버라이딩함. `Zoo` 클래스에서는 `Animal` 배열로 다양한 동물의 울음소리를 출력함.

#### 사례 2: 계산기 프로그램

```java
interface Operation {
    int execute(int a, int b);
}

class Addition implements Operation {
    @Override
    public int execute(int a, int b) {
        return a + b;
    }
}

class Subtraction implements Operation {
    @Override
    public int execute(int a, int b) {
        return a - b;
    }
}

public class Calculator {
    public static void main(String[] args) {
        var operations = new Operation[]{new Addition(), new Subtraction()};
        int a = 10, b = 5;

        for (var operation : operations) {
            System.out.println("결과: " + operation.execute(a, b));
        }
    }
}
```

이 예제에서 `Operation` 인터페이스를 구현한 `Addition`과 `Subtraction` 클래스가 각각의 연산을 수행함. `Calculator` 클래스에서는 `Operation` 배열로 다양한 연산을 처리함.

#### 사례 3: GUI 이벤트 처리

```java
interface EventListener {
    void handleEvent();
}

class ClickEventListener implements EventListener {
    @Override
    public void handleEvent() {
        System.out.println("버튼 클릭됨");
    }
}

class KeyEventListener implements EventListener {
    @Override
    public void handleEvent() {
        System.out.println("키 입력됨");
    }
}

public class EventDemo {
    public static void main(String[] args) {
        var listeners = new EventListener[]{new ClickEventListener(), new KeyEventListener()};

        for (var listener : listeners) {
            listener.handleEvent(); // 각 이벤트 처리 로직 실행
        }
    }
}
```

이 예제에서 `EventListener` 인터페이스를 구현한 클래스들이 각각의 이벤트를 처리함. `EventDemo` 클래스에서는 `EventListener` 배열로 다양한 이벤트를 처리함.

#### 사례 4: 도형 그리기 프로그램

```java
interface Shape {
    void draw();
}

class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("원 그리기");
    }
}

class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("사각형 그리기");
    }
}

public class ShapeDemo {
    public static void main(String[] args) {
        var shapes = new Shape[]{new Circle(), new Rectangle()};

        for (var shape : shapes) {
            shape.draw(); // 각 도형의 draw 메서드 호출
        }
    }
}
```

이 예제에서 `Shape` 인터페이스를 구현한 `Circle`과 `Rectangle` 클래스가 각각의 도형을 그림. `ShapeDemo` 클래스에서는 `Shape` 배열로 다양한 도형을 그림.
