# 다형성

## 업캐스팅과 다운캐스팅

### 업캐스팅과 다운캐스팅의 개념

#### 업캐스팅

업캐스팅은 자식 클래스의 객체를 부모 클래스 타입으로 변환하는 과정임. 자동으로 수행되며, 별도의 캐스트 연산자가 필요 없음. 이를 통해 코드의 유연성이 높아짐.

```java
Animal animal = new Dog(); // 업캐스팅
```

#### 다운캐스팅

다운캐스팅은 부모 클래스 타입을 자식 클래스 타입으로 변환하는 과정임. 명시적으로 캐스트 연산자를 사용해야 하며, 실행 시 타입 체크가 필요함.

```java
Dog dog = (Dog) animal; // 다운캐스팅
```

### 업캐스팅 활용

업캐스팅은 다형성을 구현하는 데 중요한 역할을 함. 여러 자식 클래스 객체를 부모 클래스 타입으로 다룰 수 있어 코드의 재사용성과 확장성이 높아짐.

```java
class Animal {
    void makeSound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("멍멍");
    }

    void fetch() {
        System.out.println("공 가져오기");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("야옹");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal[] animals = {new Dog(), new Cat()};
        for (Animal animal : animals) {
            animal.makeSound(); // 다형성 활용
        }
    }
}
```

이 예제에서 `Dog`와 `Cat` 객체는 `Animal` 배열에 저장됨. 반복문에서 각 객체의 `makeSound()` 메서드를 호출할 때, 실제 객체의 오버라이딩된 메서드가 실행됨.

### 다운캐스팅 활용

다운캐스팅은 업캐스팅된 객체를 다시 원래의 타입으로 변환할 때 사용함. 자식 클래스의 고유한 메서드를 호출해야 할 때 필요함.

```java
public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog(); // 업캐스팅
        animal.makeSound(); // "멍멍" 출력

        if (animal instanceof Dog) {
            Dog dog = (Dog) animal; // 다운캐스팅
            dog.fetch(); // "공 가져오기" 출력
        }
    }
}
```

여기서 `instanceof` 연산자로 객체의 실제 타입을 확인한 후 다운캐스팅을 수행함. 이는 `ClassCastException`을 방지하기 위한 안전한 방법임.

### 실제 사용 사례

업캐스팅과 다운캐스팅은 프레임워크나 라이브러리 설계에서 자주 사용됨. 예를 들어, GUI 컴포넌트 시스템을 구현할 때 활용할 수 있음.

```java
abstract class UIComponent {
    abstract void render();
}

class Button extends UIComponent {
    @Override
    void render() {
        System.out.println("버튼 렌더링");
    }

    void click() {
        System.out.println("버튼 클릭");
    }
}

class TextField extends UIComponent {
    @Override
    void render() {
        System.out.println("텍스트 필드 렌더링");
    }

    void input() {
        System.out.println("텍스트 입력");
    }
}

public class Main {
    public static void main(String[] args) {
        List<UIComponent> components = new ArrayList<>();
        components.add(new Button());
        components.add(new TextField());

        // 업캐스팅을 활용한 렌더링
        for (UIComponent component : components) {
            component.render();
        }

        // 다운캐스팅을 활용한 특정 동작 수행
        for (UIComponent component : components) {
            if (component instanceof Button) {
                ((Button) component).click();
            } else if (component instanceof TextField) {
                ((TextField) component).input();
            }
        }
    }
}
```
