# 연산자와 표현식

## 표현식과 문장

### 표현식의 구조와 평가

표현식은 C 언어의 근간을 이루는 요소로, 하나 이상의 피연산자와 연산자로 구성됨. 모든 표현식은 평가 결과로 값을 생성하며, 이 과정에서 타입 변환과 부작용이 발생할 수 있음.

표현식의 구조:

1. 기본 표현식: 상수, 변수, 함수 호출
2. 단항 표현식: 하나의 피연산자와 연산자 (예: !a, -b)
3. 이항 표현식: 두 개의 피연산자와 연산자 (예: a + b)
4. 삼항 표현식: 조건 연산자 ( ? : )
5. 복합 표현식: 여러 표현식의 조합

평가 과정:

1. 피연산자 값 로드
2. 필요시 암시적 형변환 수행
3. 연산자 적용
4. 임시 결과 저장
5. 부작용 처리 (있는 경우)
6. 최종 결과 반환

다음 예제를 통해 표현식의 구조와 평가를 자세히 살펴보자:

```c
#include <stdio.h>

int func(int* x) {
    return (*x)++;
}

int main() {
    int a = 5, b = 3;
    int result;

    // 복합 표현식 평가
    result = (a + b) * func(&a) - --b;
    
    printf("result: %d, a: %d, b: %d\n", result, a, b);

    return 0;
}
```

이 표현식의 평가 과정:

1. `func(&a)` 호출: `a`의 값(5) 반환 후 `a`를 6으로 증가
2. `(a + b)` 계산: 5 + 3 = 8
3. `--b` 연산: `b`를 2로 감소
4. 곱셈 연산: 8 * 5 = 40
5. 뺄셈 연산: 40 - 2 = 38
6. `result`에 최종 값 38 할당

주의할 점:

1. 시퀀스 포인트: 함수 호출과 감소 연산자 사이에 시퀀스 포인트가 있어 평가 순서가 보장됨
2. 부작용: `func(&a)`와 `--b`는 부작용을 일으키므로 주의 필요
3. 타입 변환: 모든 연산은 동일 타입에서 수행되므로 필요시 암시적 변환 발생

고급 주제:

1. 좌값(lvalue)과 우값(rvalue):
   - 좌값: 메모리 위치를 나타내는 표현식 (예: 변수)
   - 우값: 값 자체를 나타내는 표현식 (예: 상수, 연산 결과)

2. 부작용과 시퀀스 포인트:
   - 부작용: 표현식 평가 중 객체의 값이나 프로그램 상태가 변경되는 것
   - 시퀀스 포인트: 모든 부작용이 완료되고 다음 동작으로 넘어가는 지점

3. 최적화와 표현식:
   - 컴파일러는 표현식을 최적화하여 성능을 향상시킬 수 있음
   - 하지만 부작용이 있는 복잡한 표현식은 최적화를 방해할 수 있음

```c
int x = 10;
int y = (x++, x++, x++);  // 컴파일러에 따라 결과가 다를 수 있음
printf("x: %d, y: %d\n", x, y);
```

이런 코드는 명확성이 떨어지고 컴파일러 의존적이므로 피해야 함. 대신 명확하고 부작용이 분리된 코드를 작성하는 게 좋음.

표현식의 구조와 평가를 깊이 이해하면 효율적이고 예측 가능한 코드를 작성할 수 있음. 특히 복잡한 표현식을 다룰 때는 부작용, 평가 순서, 타입 변환 등을 주의 깊게 고려해야 함.
