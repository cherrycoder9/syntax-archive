# 기본 데이터 타입

## 부동 소수점형 (float, double)

부동 소수점형은 실수를 표현하는 데이터 타입임. C언어에서는 float와 double 두 가지 기본 부동 소수점 타입을 제공함. 이들은 소수점 이하의 값을 포함한 숫자를 표현할 수 있어 과학 계산, 금융 계산 등에서 중요하게 사용됨.

### float와 double의 특징

1. float: 단정밀도 부동 소수점. 일반적으로 4바이트(32비트) 사용.
2. double: 배정밀도 부동 소수점. 일반적으로 8바이트(64비트) 사용.

```c
#include <stdio.h>
#include <float.h>

int main() {
    float f = 3.14159f;
    double d = 3.141592653589793;

    printf("float: %zu바이트, 정밀도: %d자리\n", sizeof(float), FLT_DIG);
    printf("double: %zu바이트, 정밀도: %d자리\n", sizeof(double), DBL_DIG);

    printf("float 값: %.7f\n", f);
    printf("double 값: %.15lf\n", d);

    return 0;
}
```

### 부동 소수점의 내부 표현

부동 소수점은 IEEE 754 표준을 따라 표현됨. 이 표준은 부호, 지수, 가수로 실수를 표현함:

1. 부호 비트: 양수 또는 음수 표시
2. 지수: 소수점의 위치를 결정
3. 가수: 실제 숫자의 유효 자릿수

이런 표현 방식 때문에 모든 실수를 정확히 표현할 수 없고, 근사값으로 저장됨.

### 부동 소수점 리터럴

float 리터럴은 f나 F 접미사를, long double은 l이나 L 접미사를 사용함:

```c
float f1 = 3.14f;
double d1 = 3.14;  // 접미사 없으면 기본적으로 double
long double ld1 = 3.14L;
```

### 부동 소수점의 특수값

부동 소수점은 몇 가지 특수한 값을 가질 수 있음:

1. 무한대(Infinity): 오버플로우 결과나 0으로 나눈 결과로 발생
2. NaN (Not a Number): 정의되지 않은 연산 결과 (예: 0.0/0.0)

```c
#include <math.h>

double inf = 1.0 / 0.0;  // 양의 무한대
double nan = 0.0 / 0.0;  // NaN

if (isinf(inf)) printf("무한대임\n");
if (isnan(nan)) printf("NaN임\n");
```

### 부동 소수점 연산의 주의점

1. 정밀도 손실: 큰 수와 작은 수를 더할 때 작은 수가 무시될 수 있음.
2. 비교 연산: 부동 소수점은 정확한 비교가 어려움. 근사값 비교 필요.

```c
float a = 0.1f;
float b = 0.2f;
float c = 0.3f;

if (a + b == c) {
    printf("같음\n");
} else {
    printf("다름 (%.20f != %.20f)\n", a + b, c);
}
```

이 코드는 대부분의 경우 "다름"을 출력함. 부동 소수점 비교 시 epsilon 값을 사용한 근사 비교가 필요함.

### 부동 소수점 선택 시 고려사항

1. 정밀도 요구사항: 높은 정밀도가 필요하면 double 사용
2. 메모리 사용량: 메모리가 제한적이면 float 고려
3. 연산 속도: 일반적으로 float가 더 빠름
4. 표준 준수: 일부 표준(예: POSIX)은 특정 함수에 double 사용 요구

부동 소수점의 특성을 이해하고 적절히 사용하는 것은 수치 계산의 정확성과 안정성을 위해 중요함. 특히 금융 계산같이 정확성이 중요한 분야에서는 부동 소수점의 한계를 인지하고 대안(예: 고정 소수점 또는 정수 스케일링)을 고려해야 함.
