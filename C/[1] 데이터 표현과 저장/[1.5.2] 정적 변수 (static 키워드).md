# 데이터 표현과 저장

## 변수의 스코프와 수명주기

### 정적 변수 (static 키워드)

정적 변수는 `static` 키워드로 선언되며, 변수의 스코프와 수명주기에 특별한 영향을 줌. 지역 변수와 전역 변수 모두에 적용 가능하며, 각각 다른 특성을 가짐.

#### 정적 지역 변수

정적 지역 변수는 함수 내부에서 선언되지만 일반 지역 변수와 달리 프로그램이 종료될 때까지 메모리에 존재함.

특징:

- 함수 내에서만 접근 가능
- 프로그램 실행 중 한 번만 초기화됨
- 함수 호출 간 값을 유지함

사용 예시:

```c
#include <stdio.h>

void countCalls() {
    static int callCount = 0;  // 정적 지역 변수
    callCount++;
    printf("이 함수는 %d번 호출됐음\n", callCount);
}

int main() {
    for (int i = 0; i < 3; i++) {
        countCalls();
    }
    return 0;
}
```

이 예시에서 `callCount`는 함수가 호출될 때마다 증가하며, 이전 호출의 값을 기억함.

#### 정적 전역 변수

정적 전역 변수는 파일 범위 내에서만 접근 가능한 전역 변수임.

특징:

- 선언된 파일 내에서만 사용 가능
- 다른 파일에서 동일 이름의 변수와 충돌하지 않음
- 프로그램 시작 시 초기화되고 종료 시 소멸됨

사용 예시:

```c
// file1.c
#include <stdio.h>

static int sharedCounter = 0;  // 정적 전역 변수

void incrementCounter() {
    sharedCounter++;
    printf("파일1의 카운터: %d\n", sharedCounter);
}

// file2.c
#include <stdio.h>

static int sharedCounter = 100;  // file1.c의 변수와 충돌하지 않음

void printCounter() {
    printf("파일2의 카운터: %d\n", sharedCounter);
}

// main.c
int main() {
    incrementCounter();  // 파일1의 카운터: 1
    incrementCounter();  // 파일1의 카운터: 2
    printCounter();      // 파일2의 카운터: 100
    return 0;
}
```

이 예시에서 두 파일의 `sharedCounter`는 서로 독립적으로 동작함.

### 정적 변수의 활용

정적 변수는 다음과 같은 상황에서 유용함:

- 함수의 상태 유지:
   함수 호출 간 정보를 보존해야 할 때 사용함.

```c
#include <stdio.h>

int generateUniqueID() {
    static int lastID = 0;
    return ++lastID;
}

int main() {
    for (int i = 0; i < 3; i++) {
        printf("새 ID: %d\n", generateUniqueID());
    }
    return 0;
}
```

- 싱글톤 패턴 구현:
   전체 프로그램에서 단 하나의 인스턴스만 존재해야 하는 객체를 만들 때 활용함.

- 모듈화와 캡슐화:
   정적 전역 변수를 사용해 파일 간 변수 충돌을 방지하고, 모듈의 내부 상태를 숨김.

정적 변수는 메모리 사용과 코드 구조화에 영향을 주므로 신중히 사용해야 함. 과도한 사용은 코드의 복잡성을 증가시킬 수 있음. 적절히 활용하면 프로그램의 효율성과 구조를 개선할 수 있음.
