# 형 변환

## 암시적 형 변환

C 언어에서 암시적 형 변환(또는 자동 형 변환)은 프로그래머가 명시적으로 지정하지 않아도 컴파일러가 자동으로 수행하는 데이터 타입 변환을 말함. 이는 주로 다른 타입 간의 연산이나 할당 시 발생함.

### 승격 (Promotion)

작은 정수 타입이 int나 더 큰 타입으로 자동 변환되는 것을 의미함.

1. 정수 승격

   ```c
   char a = 'a';
   int b = a + 1;  // a는 int로 승격 후 연산됨
   ```

2. 실수 승격

   ```c
   float f = 3.14f;
   double d = f + 2.0;  // f는 double로 승격 후 연산됨
   ```

### 산술 변환

서로 다른 타입 간 연산 시 발생하는 자동 변환.

1. 정수와 실수 연산

   ```c
   int i = 10;
   double d = 3.14;
   double result = i + d;  // i는 double로 변환 후 연산됨
   ```

2. 서로 다른 정수 타입 간 연산

   ```c
   short s = 100;
   int i = 1000;
   int result = s + i;  // s는 int로 변환 후 연산됨
   ```

### 할당 시 변환

값을 변수에 할당할 때 발생하는 변환.

1. 넓은 범위에서 좁은 범위로의 변환

   ```c
   int i = 1000;
   char c = i;  // 상위 비트가 잘릴 수 있음 (정보 손실 가능)
   ```

2. 실수에서 정수로의 변환

   ```c
   double d = 3.14;
   int i = d;  // 소수점 이하가 잘림 (i는 3이 됨)
   ```

### 포인터 변환

1. void 포인터 변환

   ```c
   int* p_int;
   void* p_void = p_int;  // 암시적으로 허용됨
   p_int = p_void;  // C에서는 허용되지만, C++에서는 명시적 캐스팅 필요
   ```

2. 상수 포인터 변환

   ```c
   int* p_int;
   const int* p_const = p_int;  // 비상수에서 상수로 변환 허용
   // p_int = p_const;  // 오류: 상수에서 비상수로 변환 불가
   ```

### 함수 인자 전달 시 변환

함수 호출 시 인자의 타입이 매개변수 타입과 다를 경우 발생.

```c
void func(double d) { /* ... */ }

int main() {
    int i = 10;
    func(i);  // i가 double로 변환되어 전달됨
    return 0;
}
```

### 주의사항

1. 정보 손실

   ```c
   long long big = 1234567890123LL;
   int small = big;  // 상위 비트 손실 가능
   ```

2. 부호 있는 값과 부호 없는 값의 비교

   ```c
   unsigned int u = 10;
   int i = -1;
   if (u > i) {  // i가 unsigned int로 변환되어 큰 양수가 됨
       printf("예상 밖의 결과\n");
   }
   ```

3. 오버플로우와 언더플로우

   ```c
   char c = 127;
   c++;  // 오버플로우: c는 -128이 됨
   ```

4. 실수 정밀도 손실

   ```c
   float f = 1.23456789f;
   double d = f;  // 정밀도 손실 가능
   ```

암시적 형 변환은 코드를 간결하게 만들지만, 예기치 않은 결과를 초래할 수 있음. 특히 정보 손실이나 부호 관련 문제에 주의해야 함. 중요한 변환의 경우 명시적 캐스팅을 사용하여 의도를 명확히 하는 것이 좋음.
