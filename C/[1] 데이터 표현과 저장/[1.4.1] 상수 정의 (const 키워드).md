# 데이터 표현과 저장

## 상수와 리터럴

### 상수 정의 (const 키워드)

상수는 프로그램 실행 중 값이 변경되지 않는 데이터를 의미함. C 언어에서는 `const` 키워드를 사용하여 상수를 정의함. 상수를 사용하면 코드의 가독성과 유지보수성이 향상되며, 의도하지 않은 값 변경을 방지할 수 있음.

#### 기본 상수 정의

`const` 키워드를 사용하여 다양한 데이터 타입의 상수를 정의할 수 있음:

```c
#include <stdio.h>

int main() {
    const int MAX_STUDENTS = 30;
    const float PI = 3.14159f;
    const char GRADE_A = 'A';
    const char* COMPANY_NAME = "TechCorp";

    printf("최대 학생 수: %d\n", MAX_STUDENTS);
    printf("원주율: %f\n", PI);
    printf("최고 등급: %c\n", GRADE_A);
    printf("회사명: %s\n", COMPANY_NAME);

    // MAX_STUDENTS = 40;  // 컴파일 에러: 상수 값 변경 시도

    return 0;
}
```

#### 포인터와 상수

포인터와 `const`를 함께 사용할 때는 주의가 필요함. 포인터가 가리키는 값을 상수로 만들거나, 포인터 자체를 상수로 만들 수 있음:

```c
#include <stdio.h>

int main() {
    int value = 10;
    const int* ptr1 = &value;  // 포인터가 가리키는 값을 상수로
    int* const ptr2 = &value;  // 포인터 자체를 상수로
    const int* const ptr3 = &value;  // 둘 다 상수로

    // *ptr1 = 20;  // 컴파일 에러: 포인터가 가리키는 값 변경 시도
    *ptr2 = 20;  // 허용됨: 포인터가 가리키는 값 변경
    // ptr2 = &value;  // 컴파일 에러: 포인터 자체 변경 시도

    printf("value: %d\n", value);

    return 0;
}
```

#### 상수 배열

배열을 상수로 선언하면 배열의 요소를 변경할 수 없음:

```c
#include <stdio.h>

int main() {
    const int PRIMES[] = {2, 3, 5, 7, 11};
    
    // PRIMES[0] = 1;  // 컴파일 에러: 상수 배열의 요소 변경 시도

    for (int i = 0; i < 5; i++) {
        printf("%d ", PRIMES[i]);
    }
    printf("\n");

    return 0;
}
```

#### 함수 매개변수로서의 const

함수 매개변수에 `const`를 사용하면 함수 내에서 해당 매개변수의 값을 변경할 수 없음:

```c
#include <stdio.h>

void printArray(const int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
        // arr[i] = 0;  // 컴파일 에러: const 매개변수 변경 시도
    }
    printf("\n");
}

int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    printArray(numbers, 5);
    return 0;
}
```

#### const와 매크로의 차이

`const`로 정의된 상수와 `#define` 매크로로 정의된 상수는 몇 가지 차이점이 있음:

1. 타입 검사:
   - `const`: 컴파일러가 타입 검사를 수행함
   - `#define`: 단순 텍스트 대체로, 타입 검사가 없음

2. 메모리 할당:
   - `const`: 메모리에 저장됨
   - `#define`: 메모리에 저장되지 않음 (텍스트 대체)

3. 디버깅:
   - `const`: 디버거에서 값을 확인할 수 있음
   - `#define`: 전처리 단계에서 대체되므로 디버거에서 직접 확인 불가

```c
#include <stdio.h>

#define MAX_DEFINE 100
const int MAX_CONST = 100;

int main() {
    printf("매크로 상수: %d\n", MAX_DEFINE);
    printf("const 상수: %d\n", MAX_CONST);

    return 0;
}
```

#### const 사용의 장점

1. 가독성 향상: 상수 값의 의미를 명확히 전달함
2. 안전성 증가: 의도하지 않은 값 변경을 방지함
3. 유지보수 용이: 상수 값을 한 곳에서 관리할 수 있음
4. 컴파일러 최적화: `const`를 사용하면 컴파일러가 더 효율적인 코드를 생성할 수 있음

```c
#include <stdio.h>

const float TAX_RATE = 0.1f;

float calculateTax(float price) {
    return price * TAX_RATE;
}

int main() {
    float itemPrice = 100.0f;
    float tax = calculateTax(itemPrice);
    
    printf("상품 가격: %.2f\n", itemPrice);
    printf("세금: %.2f\n", tax);
    printf("총 가격: %.2f\n", itemPrice + tax);

    return 0;
}
```
